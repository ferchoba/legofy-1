#!/usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import division

import numpy
from matplotlib import pyplot, colors


def legofy(img, fname=False):
    """A python function to convert an image into a lego-like image.

    Usage
    -----

    A simple example can be generated by using an array with random values:

        >>> import numpy
        >>> import legofy
        >>> from matplotlib import pyplot
        >>>
        >>> im = numpy.random.rand(10, 10)
        >>> im_lego = legofy(im)
        >>> _ = pyplot.imshow(im_lego, interpolation='none', origin='lower')

    But I want to do it with my profile picture, how can I do it?!

        >>> from scipy import misc
        >>> from matplotlib import pyplot
        >>> import urllib
        >>> import cStringIO
        >>> import legofy
        >>>
        >>> url = 'http://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg/161px-Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg'
        >>> im = misc.imread(cStringIO.StringIO(urllib.urlopen(url).read()))
        >>> im = misc.imresize(im, (50, 33), interp='nearest')
        >>> im = 1-(255-im)/(255)
        >>> im_lego = legofy(im)
        >>> _ = pyplot.imshow(im_lego, interpolation='none', origin='lower')


    Parameters
    ----------

    img : array_like
        RGB image array, ``(ni, nj, 3)``. It can be anything you want, as long
        as each channel is normalized ``[0, 1]``.

    fname : str, optional
        File name. It is default to ``False``, if a string is present it should
        contain the file name and extension to save the output image.


    Returns
    -------

    img_lego : array_like
        RGB image array, ``(ni*px, nj*px, 3)`` where ``px`` is the oversampled
        pixel number used to draw the features of each lego brick.


    Notes
    -----

    Please, just **please**, resample your input images. The code is really
    inefficient and will probably crash if the image is too big.

    The dimensions of the blocks were extracted from [1]_.


    References
    ----------

    .. [1] http://www.robertcailliau.eu/Lego/Dimensions/zMeasurements-en.xhtml

    """

    px = 101
    lego = {'pitch':8, 'knob':4.8, 'tol':0.2}

    ni, nj, _ = numpy.shape(img)

    imge = numpy.repeat(img, px, axis=0)
    imge = numpy.repeat(imge, px, axis=1)


    r = int((lego['knob']/lego['pitch'])*px/2)
    ic, jc = numpy.mgrid[0:px, 0:px]
    ind = (ic-px/2)**2+(jc-px/2)**2-r**2<0

    inde = numpy.tile(ind, (ni, 1))
    inde = numpy.tile(inde, (1, nj))

    line = numpy.logical_or(ic > int((1-lego['tol']/lego['pitch'])*px),
                            jc > int((1-lego['tol']/lego['pitch'])*px))
    linee = numpy.tile(line, (ni, 1))
    linee = numpy.tile(linee, (1, nj))

    light = numpy.roll(numpy.roll(inde, -int(r*0.1), axis=0), -int(r*0.1), axis=1)
    light = numpy.logical_and(numpy.invert(inde), light)

    shadow = numpy.roll(numpy.roll(inde, int(r*0.1), axis=0), int(r*0.1), axis=1)
    shadow = numpy.logical_and(numpy.invert(inde), shadow)

    imgl = colors.rgb_to_hsv(imge)

    imgl[numpy.invert(inde), 2] *= 0.80
    imgl[inde, 2] *= 1.15
    imgl[light, 2] *= 1.1
    imgl[shadow, 2] *=  0.9
    imgl[linee, 2] *= 0.95

    imgl = colors.hsv_to_rgb(numpy.clip(imgl, 0, 1))

    if fname:
        fig = pyplot.imshow(imgl, interpolation='nearest')
        _ = pyplot.axis('off')
        fig.axes.get_xaxis().set_visible(False)
        fig.axes.get_yaxis().set_visible(False)
        pyplot.savefig(fname, dpi=300, bbox_inches='tight', pad_inches=0)

    return imgl
